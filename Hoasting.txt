ğŸ§  1ï¸âƒ£ Pehle samajh: JavaScript ka execution 2 phase me hota hai

 jab bhi JS koi function ya global code chalata hai,wo 2 phases me karta hai:

    âœ… (1) Memory Creation Phase(Hoisting phase)

    * sab variables aur functions ke liye memory allocate hoti hai
    * JS engine variables aur functions ko scan karta hai
    * â€œfunction declarationsâ€ ka pura body memory me chali jaati hai
    * â€œvariablesâ€ ke liye sirf undefined assign hota hai(agar var hai)
    
    âœ… (2) Execution Phase

    * ab line by line code execute hota hai
    * values assign hoti hain
    * functions call hote hain
    * expressions evaluate hote hain

âš™ï¸ 2ï¸âƒ£ Ab samajh â€” Hoisting exactly kya hai?

-> â€œHoistingâ€ ka matlab hai:
* JS engine code run karne se pehle,variable aur function declarations ko memory me move kar leta hai (top pe) during compile time.
* Isliye agar tu kisi variable ko use kare before declaration,to error nahi, undefined milta hai (agar var hai).

ğŸ” 3ï¸âƒ£ Example 1: Basic hoisting with var

    console.log(a); // â“ kya output hoga?
    var a = 10;

    ğŸ‘‰ Step by step:

        1. Memory creation phase:
            -> JS engine dekhta hai var a
            -> memory me a: undefined store hota hai

       2.  Execution phase:

        -> line 1: print karega undefined (kyunki value abhi assign nahi hui)
        -> line 3: ab a ko assign karta hai 10
        âœ… Output: undefined


ğŸ” 4ï¸âƒ£ Example 2: Let / Const ke saath Hoisting kaise alag hai

    console.log(a); // âŒ ReferenceError
    let a = 10;

    Explain:-
    -> Let aur const bhi hoist hote hain par difference ye hai â†’ wo temporal dead zone (TDZ) me rehte hain jab tak unhe assign nahi kiya jata.
    -> â€œTDZâ€ = time between hoisting and initialization.Us time me unko access karne par error aata hai.

ğŸ” 5ï¸âƒ£ Example 3: Function Declaration vs Function Expression

   * Function Declaration

        sayHi(); // âœ… Works

        function sayHi() {
        console.log('Hello Bhai!');
        }

        Explain:-
            Function Declaration poora memory me chala jaata hai (pura body ke saath) Isliye use pehle call karne pe bhi chalega.

    * Function Expression

    sayHi(); // âŒ TypeError

    var sayHi = function() {
        console.log('Hello Bhai!');
    };

    Explain:-
       Ye function expression hai â€” aur var ke sath declare hua hai.

        * memory phase me sayHi = undefined
        * jab tak line 3 execute nahi hoti,sayHi ek â€œundefinedâ€ hai, callable nahi.

ğŸ” 6ï¸âƒ£ Example 4: Under the hood â€” how memory and execution context banta hai

    var a = 10;

    function test() {
        var b = 20;
        console.log(a, b);
    }
    test();

    Step 1: Global Execution Context (GEC)
        Jab program start hota hai â†’
       -> JS ek Global Execution Context banata hai, jisme do cheeze hoti hain:

      1.1 Memory phase (creation):

        a: undefined
        test: Æ’ test()

      1.2 Execution phase:

        a = 10
        test() call â†’ new Function Execution Context (FEC) banta hai.

    Step 2: Function Execution Context (for test)

        Ab test() call hone pe JS ek naya context stack pe push karta hai.

        2.1 Memory phase:

            b: undefined

        2.2 Execution phase:

        b = 20
        console.log(a, b) // lexical scope ke through a=10 milta hai

        explain:-
            ğŸ” jab function complete hota hai,
            wo context stack se pop ho jata hai.


ğŸ§© 7ï¸âƒ£ Under the Hood Summary (ek visual jaisa soch)

    console.log(x);
    var x = 5;
    function greet() { console.log('Hello'); }
    greet();    

    1. Memory Creation Phase:

        x -> undefined
        greet -> Æ’ greet()

    2. Execution Phase:

    console.log(x) // undefined
    x = 5
    greet() // "Hello"


âš¡ 8ï¸âƒ£ Bonus: Arrow functions aur Hoisting

    greet(); // âŒ Cannot access 'greet' before initialization
    const greet = () => console.log("Yo!");

    Arrow functions bhi expressions hote hain,to ye bhi hoist hote hain par TDZ me rehte hain (tab tak use nahi kar sakte jab tak initialized na ho jaaye).


ğŸ§¨ Final Recap (tera style me bhai ğŸ’¬)

ğŸ”¸ Hoisting = JS engine pehle se variables/functions ki jagah reserve kar leta hai
ğŸ”¸ var â†’ undefined assign hota hai
ğŸ”¸ let/const â†’ hoist hote hain, par TDZ me rehte hain (error before use)
ğŸ”¸ Function declaration puri memory me chali jaati hai (pehle se available hoti hai)
ğŸ”¸ Execution time tab lagta hai jab values assign ya functions run karte ho
ğŸ”¸ Hoisting compile time (creation phase) me hoti hai, run time me nahi






